package com.nordicpeak.flowengine.beans;

import java.lang.reflect.Field;
import java.sql.Blob;
import java.sql.Date;
import java.util.ArrayList;
import java.util.List;

import javax.sql.rowset.serial.SerialBlob;

import org.w3c.dom.Document;
import org.w3c.dom.Element;

import se.unlogic.openhierarchy.foregroundmodules.siteprofile.interfaces.SiteProfile;
import se.unlogic.standardutils.annotations.NoDuplicates;
import se.unlogic.standardutils.annotations.PopulateOnlyIfSet;
import se.unlogic.standardutils.annotations.RequiredIfSet;
import se.unlogic.standardutils.annotations.SplitOnLineBreak;
import se.unlogic.standardutils.annotations.WebPopulate;
import se.unlogic.standardutils.crypto.Base64;
import se.unlogic.standardutils.dao.annotations.DAOManaged;
import se.unlogic.standardutils.dao.annotations.Key;
import se.unlogic.standardutils.dao.annotations.ManyToOne;
import se.unlogic.standardutils.dao.annotations.OneToMany;
import se.unlogic.standardutils.dao.annotations.OrderBy;
import se.unlogic.standardutils.dao.annotations.SimplifiedRelation;
import se.unlogic.standardutils.dao.annotations.Table;
import se.unlogic.standardutils.date.DateStringyfier;
import se.unlogic.standardutils.date.DateUtils;
import se.unlogic.standardutils.populators.StringPopulator;
import se.unlogic.standardutils.reflection.ReflectionUtils;
import se.unlogic.standardutils.string.StringTag;
import se.unlogic.standardutils.string.StringUtils;
import se.unlogic.standardutils.validation.ValidationError;
import se.unlogic.standardutils.validation.ValidationException;
import se.unlogic.standardutils.xml.GeneratedElementable;
import se.unlogic.standardutils.xml.XMLElement;
import se.unlogic.standardutils.xml.XMLParser;
import se.unlogic.standardutils.xml.XMLParserPopulateable;
import se.unlogic.standardutils.xml.XMLPopulationUtils;
import se.unlogic.standardutils.xml.XMLUtils;
import se.unlogic.standardutils.xml.XMLValidationUtils;
import se.unlogic.webutils.annotations.URLRewrite;
import se.unlogic.webutils.populators.StringHTTPURLPopulator;

import com.nordicpeak.flowengine.annotations.TextTagReplace;
import com.nordicpeak.flowengine.interfaces.ImmutableFlow;
import com.nordicpeak.flowengine.utils.TextTagReplacer;

@Table(name = "flowengine_flows")
@XMLElement
public class Flow extends GeneratedElementable implements ImmutableFlow, XMLParserPopulateable {

	private static final long serialVersionUID = -1533312692687401406L;

	public static final Field DEFAULT_FLOW_STATE_MAPPINGS_RELATION = ReflectionUtils.getField(Flow.class, "defaultFlowStateMappings");
	public static final Field FLOW_TYPE_RELATION = ReflectionUtils.getField(Flow.class, "flowType");
	public static final Field CATEGORY_RELATION = ReflectionUtils.getField(Flow.class, "category");
	public static final Field FLOW_FAMILY_RELATION = ReflectionUtils.getField(Flow.class, "flowFamily");
	public static final Field STEPS_RELATION = ReflectionUtils.getField(Flow.class, "steps");
	public static final Field STATUSES_RELATION = ReflectionUtils.getField(Flow.class, "statuses");
	public static final Field TAGS_RELATION = ReflectionUtils.getField(Flow.class, "tags");
	public static final Field CHECKS_RELATION = ReflectionUtils.getField(Flow.class, "checks");
	public static final Field FLOW_INSTANCES_RELATION = ReflectionUtils.getField(Flow.class, "flowInstances");

	public static final Field ICON_BLOB_FIELD = ReflectionUtils.getField(Flow.class, "icon");

	@DAOManaged(autoGenerated = true)
	@Key
	@XMLElement
	private Integer flowID;

	@StringTag
	@DAOManaged
	@OrderBy
	@WebPopulate(required = true, maxLength = 255)
	@XMLElement
	private String name;

	@DAOManaged
	@StringTag
	@XMLElement
	private Integer version;

	@TextTagReplace
	@StringTag
	@DAOManaged
	@URLRewrite
	@WebPopulate(required = true, maxLength = 65535)
	private String shortDescription;

	@TextTagReplace
	@StringTag
	@DAOManaged
	@URLRewrite
	@WebPopulate(required = true, maxLength = 16777215)
	private String longDescription;

	@TextTagReplace
	@DAOManaged
	@URLRewrite
	@WebPopulate(maxLength = 16777215)
	@RequiredIfSet(paramName= "typeOfFlow", value = "INTERNAL")
	private String submittedMessage;

	@DAOManaged
	@XMLElement
	private String iconFileName;

	@DAOManaged
	private transient Blob icon;

	@StringTag
	@DAOManaged
	@WebPopulate
	@RequiredIfSet(paramName = "unPublishDate")
	@XMLElement(valueFormatter = DateStringyfier.class)
	private Date publishDate;

	@StringTag
	@DAOManaged
	@WebPopulate
	@XMLElement(valueFormatter = DateStringyfier.class)
	private Date unPublishDate;

	@DAOManaged
	@WebPopulate
	@XMLElement
	private boolean enabled;

	@DAOManaged
	@WebPopulate
	@XMLElement
	private boolean usePreview;

	@DAOManaged
	@WebPopulate
	@XMLElement
	private boolean requireAuthentication;

	@DAOManaged
	@WebPopulate
	@XMLElement
	private boolean requireSigning;

	@DAOManaged
	@WebPopulate
	@XMLElement
	private boolean showSubmitSurvey;
	
	@DAOManaged
	@OneToMany
	@SimplifiedRelation(table = "flowengine_flow_tags", remoteValueColumnName = "tag")
	@WebPopulate(maxLength = 255)
	@NoDuplicates
	@SplitOnLineBreak
	@XMLElement(fixCase = true, childName = "tag")
	private List<String> tags;

	@DAOManaged
	@OneToMany
	@SimplifiedRelation(table = "flowengine_flow_checks", remoteValueColumnName = "value")
	@WebPopulate(maxLength = 255)
	@NoDuplicates
	@SplitOnLineBreak
	@XMLElement(fixCase = true, childName = "check")
	private List<String> checks;

	@DAOManaged(columnName = "flowTypeID")
	@ManyToOne
	@XMLElement
	private FlowType flowType;

	@DAOManaged(columnName = "categoryID")
	@ManyToOne
	@XMLElement
	private Category category;

	@DAOManaged(columnName = "flowFamilyID")
	@ManyToOne
	@XMLElement
	private FlowFamily flowFamily;

	@DAOManaged
	@OneToMany
	@XMLElement(fixCase = true)
	private List<Status> statuses;

	@DAOManaged
	@OneToMany
	@XMLElement
	private List<DefaultStatusMapping> defaultFlowStateMappings;

	@DAOManaged
	@OneToMany
	@XMLElement(fixCase = true)
	private List<Step> steps;

	@DAOManaged
	@OneToMany
	@XMLElement
	private List<FlowInstance> flowInstances;

	@DAOManaged
	@WebPopulate(populator = StringHTTPURLPopulator.class, maxLength = 255)
	@PopulateOnlyIfSet(paramNames = { "typeOfFlow" }, paramValues = { "EXTERNAL" })
	@RequiredIfSet(paramName= "typeOfFlow", value = "EXTERNAL")
	@XMLElement
	private String externalLink;

	@XMLElement
	private Integer flowInstanceCount;

	@XMLElement
	private Boolean latestVersion;

	@XMLElement
	private Boolean popular;

	@XMLElement
	private boolean hasTextTags;

	@Override
	public Integer getFlowID() {

		return flowID;
	}

	public void setFlowID(Integer flowID) {

		this.flowID = flowID;
	}

	@Override
	public String getName() {

		return name;
	}

	public void setName(String name) {

		this.name = name;
	}

	@Override
	public Category getCategory() {

		return category;
	}

	public void setCategory(Category category) {

		this.category = category;
	}

	public List<Status> getStatuses() {

		return statuses;
	}

	public void setStatuses(List<Status> flowStates) {

		this.statuses = flowStates;
	}

	@Override
	public List<Step> getSteps() {

		return steps;
	}

	public void setSteps(List<Step> steps) {

		this.steps = steps;
	}

	public List<FlowInstance> getFlowInstances() {

		return flowInstances;
	}

	public void setFlowInstances(List<FlowInstance> flowInstances) {

		this.flowInstances = flowInstances;
	}

	public String getShortDescription() {

		return shortDescription;
	}

	public void setShortDescription(String shortDescription) {

		this.shortDescription = shortDescription;
	}

	public String getLongDescription() {

		return longDescription;
	}

	public void setLongDescription(String longDescription) {

		this.longDescription = longDescription;
	}

	public String getIconFileName() {

		return iconFileName;
	}

	public void setIconFileName(String iconFileName) {

		this.iconFileName = iconFileName;
	}

	public Blob getIcon() {

		return icon;
	}

	public void setIcon(Blob icon) {

		this.icon = icon;
	}

	public Date getPublishDate() {

		return publishDate;
	}

	public void setPublishDate(Date publishDate) {

		this.publishDate = publishDate;
	}

	public Date getUnPublishDate() {

		return unPublishDate;
	}

	public void setUnPublishDate(Date unPublishDate) {

		this.unPublishDate = unPublishDate;
	}

	@Override
	public FlowType getFlowType() {

		return flowType;
	}

	public void setFlowType(FlowType flowType) {

		this.flowType = flowType;
	}

	public boolean isEnabled() {

		return enabled;
	}

	public void setEnabled(boolean disabled) {

		this.enabled = disabled;
	}

	@Override
	public boolean isPublished() {

		Date currentDate = DateUtils.getCurrentSQLDate(false);

		if (publishDate == null || publishDate.after(currentDate)) {

			return false;

		} else if (unPublishDate != null && unPublishDate.before(currentDate)) {

			return false;
		}

		return true;
	}

	public boolean hasTextTags() {

		return hasTextTags;
	}

	public void setHasTextTags(boolean hasTextTags) {

		this.hasTextTags = hasTextTags;
	}

	@Override
	public String toString() {

		return name + " (ID: " + flowID + ")";
	}

	@Override
	public boolean usesPreview() {

		return usePreview;
	}

	public void setUsePreview(boolean usePreview) {

		this.usePreview = usePreview;
	}

	@Override
	public String getSubmittedMessage() {

		return submittedMessage;
	}

	public void setSubmittedMessage(String submittedMessage) {

		this.submittedMessage = submittedMessage;
	}

	public List<DefaultStatusMapping> getDefaultFlowStateMappings() {

		return defaultFlowStateMappings;
	}

	public void setDefaultFlowStateMappings(List<DefaultStatusMapping> defaultFlowStateMappings) {

		this.defaultFlowStateMappings = defaultFlowStateMappings;
	}

	@Override
	public Status getDefaultState(String actionID) {

		if (this.defaultFlowStateMappings != null) {

			for (DefaultStatusMapping flowStateMapping : this.defaultFlowStateMappings) {

				if (flowStateMapping.getActionID().equals(actionID)) {

					return flowStateMapping.getStatus();
				}
			}
		}

		return null;
	}

	public boolean isExpired() {

		Date currentDate = DateUtils.getCurrentSQLDate(false);

		if (unPublishDate != null && unPublishDate.before(currentDate)) {

			return true;
		}

		return false;
	}

	@Override
	public Element toXML(Document doc) {

		Element flowElement = super.toXML(doc);

		XMLUtils.appendNewElement(doc, flowElement, "shortDescription", shortDescription);
		XMLUtils.appendNewElement(doc, flowElement, "longDescription", longDescription);
		XMLUtils.appendNewElement(doc, flowElement, "submittedMessage", submittedMessage);
		XMLUtils.appendNewElement(doc, flowElement, "published", isPublished());

		return flowElement;
	}

	public Element toXML(Document doc, SiteProfile siteProfile) {

		if (siteProfile == null || !hasTextTags) {

			return this.toXML(doc);
		}

		Element flowElement = super.toXML(doc);

		if (hasTextTags) {

			if (shortDescription != null) {

				XMLUtils.appendNewElement(doc, flowElement, "shortDescription", TextTagReplacer.replaceTextTags(shortDescription, siteProfile.getSettingHandler()));
			}

			if (longDescription != null) {

				XMLUtils.appendNewElement(doc, flowElement, "longDescription", TextTagReplacer.replaceTextTags(longDescription, siteProfile.getSettingHandler()));
			}

			if (submittedMessage != null) {

				XMLUtils.appendNewElement(doc, flowElement, "submittedMessage", TextTagReplacer.replaceTextTags(submittedMessage, siteProfile.getSettingHandler()));
			}

		}

		XMLUtils.appendNewElement(doc, flowElement, "published", isPublished());

		return flowElement;

	}

	public Integer getFlowInstanceCount() {

		return flowInstanceCount;
	}

	public void setFlowInstanceCount(Integer flowInstanceCount) {

		this.flowInstanceCount = flowInstanceCount;
	}

	@Override
	public FlowFamily getFlowFamily() {

		return flowFamily;
	}

	public void setFlowFamily(FlowFamily flowFamily) {

		this.flowFamily = flowFamily;
	}

	@Override
	public Integer getVersion() {

		return version;
	}

	public void setVersion(Integer version) {

		this.version = version;
	}

	public boolean isLatestVersion() {

		return latestVersion != null && latestVersion;
	}

	public void setLatestVersion(Boolean latestVersion) {

		this.latestVersion = latestVersion;
	}

	@Override
	public List<String> getTags() {

		return tags;
	}

	public void setTags(List<String> tags) {

		this.tags = tags;
	}

	@Override
	public List<String> getChecks() {

		return checks;
	}

	public void setChecks(List<String> checks) {

		this.checks = checks;
	}

	public void setRequireAuthentication(boolean requireAuthentication) {

		this.requireAuthentication = requireAuthentication;
	}

	@Override
	public boolean requiresAuthentication() {

		return requireAuthentication;
	}

	public Boolean getPopular() {

		return popular;
	}

	public void setPopular(Boolean popular) {

		this.popular = popular;
	}

	@Override
	public int hashCode() {

		final int prime = 31;
		int result = 1;
		result = prime * result + ((flowID == null) ? 0 : flowID.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {

		if (this == obj) {
			return true;
		}
		if (obj == null) {
			return false;
		}
		if (getClass() != obj.getClass()) {
			return false;
		}
		Flow other = (Flow) obj;
		if (flowID == null) {
			if (other.flowID != null) {
				return false;
			}
		} else if (!flowID.equals(other.flowID)) {
			return false;
		}
		return true;
	}

	@Override
	public boolean requiresSigning() {

		return requireSigning;
	}

	public void setRequireSigning(boolean requireSigning) {

		this.requireSigning = requireSigning;
	}

	
	public boolean showsSubmitSurvey() {
	
		return showSubmitSurvey;
	}

	
	public void setShowSubmitSurvey(boolean showSubmitSurvey) {
	
		this.showSubmitSurvey = showSubmitSurvey;
	}

	public String getExternalLink() {

		return externalLink;
	}

	public void setExternalLink(String externalLink) {

		this.externalLink = externalLink;
	}

	public boolean isInternal() {

		return externalLink == null;
	}

	@Override
	public void populate(XMLParser xmlParser) throws ValidationException {

		List<ValidationError> errors = new ArrayList<ValidationError>();

		this.name = XMLValidationUtils.validateParameter("name", xmlParser, true, 1, 255, StringPopulator.getPopulator(), errors);
		this.shortDescription = XMLValidationUtils.validateParameter("shortDescription", xmlParser, true, 1, 65535, StringPopulator.getPopulator(), errors);
		this.longDescription = XMLValidationUtils.validateParameter("longDescription", xmlParser, true, 1, 16777215, StringPopulator.getPopulator(), errors);

		this.iconFileName = XMLValidationUtils.validateParameter("iconFileName", xmlParser, false, 1, 255, StringPopulator.getPopulator(), errors);

		String icon = xmlParser.getString("icon");

		if(!StringUtils.isEmpty(icon)){

			try{
				this.icon = new SerialBlob(Base64.decode(icon));

			}catch(Exception e){

				errors.add(new ValidationError("ErrorParsingFlowIcon"));
			}
		}

		//DatePopulator datePopulator = new DatePopulator();

		//this.publishDate = XMLValidationUtils.validateParameter("publishDate", xmlParser, false, datePopulator, errors);
		//this.unPublishDate = XMLValidationUtils.validateParameter("unPublishDate", xmlParser, false, datePopulator, errors);

		this.usePreview = xmlParser.getPrimitiveBoolean("usePreview");
		this.requireAuthentication = xmlParser.getPrimitiveBoolean("requireAuthentication");
		this.requireSigning = xmlParser.getPrimitiveBoolean("requireSigning");

		this.tags = XMLValidationUtils.validateParameters("Tags/tag", xmlParser, false, 1, 255, StringPopulator.getPopulator(), errors);
		this.checks = XMLValidationUtils.validateParameters("Checks/check", xmlParser, false, 1, 255, StringPopulator.getPopulator(), errors);

		this.externalLink = XMLValidationUtils.validateParameter("externalLink", xmlParser, false, 1, 255, StringPopulator.getPopulator(), errors);

		//Only populated if no externalLink is set
		if(externalLink == null){

			this.submittedMessage = XMLValidationUtils.validateParameter("submittedMessage", xmlParser, true, 1, 16777215, StringPopulator.getPopulator(), errors);

			this.statuses = XMLPopulationUtils.populateBeans(xmlParser, "Statuses/Status", Status.class, errors);
			this.defaultFlowStateMappings = XMLPopulationUtils.populateBeans(xmlParser, "defaultFlowStateMappings/DefaultStatusMapping", DefaultStatusMapping.class, errors);
			this.steps = XMLPopulationUtils.populateBeans(xmlParser, "Steps/Step", Step.class, errors);
		}

		if(!errors.isEmpty()){

			throw new ValidationException(errors);
		}
	}
}
